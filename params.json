{"name":"Epazote","tagline":"Automated Microservices  Supervisor","body":"[![Download](https://api.bintray.com/packages/nbari/epazote/epazote/images/download.svg)](https://bintray.com/nbari/epazote/epazote/_latestVersion)\r\n[![Build Status](https://drone.io/github.com/nbari/epazote/status.png)](https://drone.io/github.com/nbari/epazote/latest)\r\n[![Build Status](https://travis-ci.org/nbari/epazote.svg?branch=develop)](https://travis-ci.org/nbari/epazote)\r\n[![Coverage Status](https://coveralls.io/repos/github/nbari/epazote/badge.svg?branch=master)](https://coveralls.io/github/nbari/epazote?branch=master)\r\n\r\n# Epazote ðŸŒ¿\r\nAutomated Microservices Supervisor\r\n\r\n**Epazote** automatically update/add services specified in a file call\r\n``epazote.yml``. Periodically checks the defined endpoints and execute recovery\r\ncommands in case services responses are not behaving like expected helping with\r\nthis to automate actions in order to keep services/applications up and running.\r\n\r\nIn Continuous Integration/Deployment environments the file ``epazote.yml`` can\r\ndynamically be updated/change without need to restart the supervisor, avoiding\r\nwith this an extra dependency on the deployment flow which could imply to\r\nrestart the supervisor, in this case **Epazote**.\r\n\r\n## How it works\r\nIn its basic way of operation, **Epazote** periodically checks the services endpoints\r\n\"[URLs](https://en.wikipedia.org/wiki/Uniform_Resource_Locator)\"\r\nby doing an [HTTP GET Request](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods),\r\nbased on the response [Status code](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes),\r\n[Headers](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields) or\r\neither the\r\n[body](https://en.wikipedia.org/wiki/HTTP_message_body), it executes a command.\r\n\r\nIn most scenarios, is desired to apply a command directly to the application in\r\ncause, like a signal (``kill -HUP``), or either a restart (``sv restart app``),\r\ntherefore in this case **Epazote** and the application should be running on the\r\nsame server.\r\n\r\n**Epazote** can also work in a standalone mode by only monitoring and sending\r\nalerts if desired.\r\n\r\n# How to use it\r\nFirst you need to install **Epazote**, either you can compile it from\r\n[source](https://github.com/nbari/epazote)\r\nor download a pre-compiled binary matching your operating system from here:\r\nhttps://dl.bintray.com/nbari/epazote/\r\n\r\n [![Download](https://api.bintray.com/packages/nbari/epazote/epazote/images/download.svg)](https://bintray.com/nbari/epazote/epazote/_latestVersion)\r\n\r\n> To compile from source, after downloading the sources use ``make`` to build the binary\r\n\r\n**Epazote** was designed with simplicity in mind, as an easy tool for\r\n[DevOps](https://en.wikipedia.org/wiki/DevOps) and as a complement to\r\ninfrastructure orchestration tools like [Ansible](http://www.ansible.com/) and\r\n[SaltStack](http://saltstack.com/), because of this [YAML](http://www.yaml.org/)\r\nis used for the configuration files, avoiding with this, the learn of a new\r\nlanguage or syntax, and simplifying the setup.\r\n\r\n## The configuration file\r\n\r\nThe configuration file ([YAML formated](https://en.wikipedia.org/wiki/YAML))\r\nconsists of two parts, a **config** and a **services** (Key-value pairs).\r\n\r\n## The config section\r\n\r\nThe **config** section is composed of:\r\n\r\n    - smtp (Email settings for sending notification)\r\n    - scan (Paths used to find the file 'epazote.yml')\r\n\r\nExample:\r\n\r\n```yaml\r\nconfig:\r\n    smtp:\r\n        username: smtp@domain.tld\r\n        password: password\r\n        server: mail.example.com\r\n        port: 587\r\n        headers:\r\n            from: epazote@domain.tld\r\n            to: team@domain.tld ops@domain.tld etc@domain.tld\r\n            subject: \"[name - status]\"\r\n    scan:\r\n        paths:\r\n            - /arena/home/sites\r\n            - /home/apps\r\n        minutes: 5\r\n```\r\n\r\n### config - smtp\r\n\r\nRequired to properly send alerts via email, all fields are required, the\r\n``headers`` section can be extended with any desired key-pair values.\r\n\r\n### config - smtp - subject (because exit name output status url)\r\nThe subject can be formed by using this keywords: ``because`` ``exit`` ``name``\r\n``output`` ``status`` ``url`` on the previous example, ``subject: [name - status]``\r\nwould transform to ``[my service - 500]`` the ``name`` has replaced\r\nby the service name, ``my service`` and ``status`` by the response status code\r\n``500`` in this case.\r\n\r\n### config - scan\r\n\r\nPaths to scan every N ``seconds``, ``minutes`` or ``hours``, a search for\r\nservices specified in a file call ``epazote.yml`` is made.\r\n\r\nThe **scan** setting is optional however is very useful when doing Continues\r\nDeployments. for example if your code is automatically uploaded to the\r\ndirectory ``/arena/home/sites/application_1`` and your scan paths contain\r\n``/arena/home/sites``, you could simple upload on your application directory a\r\nfile named ``epazote.yml`` with the service rules, thus achieving the deployment\r\nof your application and the supervising at the same time.\r\n\r\n### config (optional)\r\n\r\nAs you may notice the ``config`` section contains mainly settings for sending\r\nalerts/notifications apart from the ``scan`` setting, therefore is totally\r\noptional, meaning that **Epazote** can still run and check your services without\r\nthe need of the ``config`` section.\r\n\r\nIf you want to automatically update/load services you will need the\r\n``config - scan`` setting.\r\n\r\n\r\n## The services section\r\n\r\nServices are the main functionality of **Epazote**, is where the URL's and the\r\nrules based on the response are defined, since options vary from service to\r\nservice, an example could help better to understand the setup:\r\n\r\n```yaml\r\nservices:\r\n    my service 1:\r\n        url: http://myservice.domain.tld/_healthcheck_\r\n        timeout: 5\r\n        seconds: 60\r\n        log: http://monitor.domain.tld\r\n        expect:\r\n            status: 200\r\n            header:\r\n                content-type: application/json; charset=UTF-8\r\n            body: find this string on my site\r\n            if_not:\r\n                cmd: sv restart /services/my_service_1\r\n                notify: team@domain.tld\r\n                msg: |\r\n                    line 1 bla bla\r\n                    line 2\r\n        if_status:\r\n            500:\r\n                cmd: reboot\r\n            404:\r\n                cmd: sv restart /services/cache\r\n                msg: restarting cache\r\n                notify: team@domain.tld x@domain.tld\r\n        if_header:\r\n            x-amqp-kapputt:\r\n                cmd: restart abc\r\n                notify: bunny@domain.tld\r\n                msg: |\r\n                    The rabbit is angry\r\n                    & hungry\r\n            x-db-kapputt:\r\n                cmd: svc restart /services/db\r\n\r\n    other service:\r\n        url: http://other-service.domain.tld/ping\r\n        minutes: 3\r\n\r\n    redirect service:\r\n        url: http://test.domain.tld/\r\n        hour: 1\r\n        expect:\r\n            status: 302\r\n            if_not:\r\n                cmd: service restart abc\r\n                notify: yes\r\n\r\n    salt-master:\r\n        test: pgrep -f salt\r\n        if_not:\r\n            cmd: service restart salt_master\r\n            notify: operations@domain.tld\r\n```\r\n\r\n### services - name of service (string)\r\nAn unique string that identifies your service, in the above example, there are 3\r\nservices named:\r\n - my service 1\r\n - other service\r\n - redirect service\r\n\r\n### services - url (string)\r\nURL of the service to supervise\r\n\r\n### services - timeout in seconds (int)\r\nTimeout specifies a time limit for the HTTP requests, A value of zero means no\r\ntimeout, defaults to 5 seconds.\r\n\r\n### services - seconds, minutes, hours\r\nHow often to check the service, the options are: (Only one should be used)\r\n - seconds N\r\n - minutes N\r\n - hours N\r\n\r\n``N`` should be an integer.\r\n\r\n### services - log (URL)\r\nAn URL to post all events, default disabled.\r\n\r\n### services - expect\r\nThe ``expect`` block options are:\r\n- status (int)\r\n- header (string)\r\n- body   (regular expression)\r\n- if_not (Action block)\r\n\r\n### services - expect - status\r\nAn Integer representing the expected [HTTP Status Code](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes)\r\n\r\n### services - expect - header\r\nA key-value map of expected headers, it can be only one or more.\r\n\r\n### services - expect - body\r\nA [regular expression](https://en.wikipedia.org/wiki/Regular_expression) used\r\nto match a string on the body of the site, use full in cases you want to ensure\r\nthat the content delivered is always the same or keeps a pattern.\r\n\r\n### services - expect (How it works)\r\nThe ``expect`` logic tries to implement a\r\n[if-else](https://en.wikipedia.org/wiki/if_else) logic ``status``, ``header``,\r\n``body`` are the **if** and the ``if_not`` block becomes the **else**.\r\n\r\n    if\r\n        status\r\n        header\r\n        body\r\n    else:\r\n        if_not\r\n\r\nIn must cases only one option is required, check on the above example for the service named \"redirect service\".\r\n\r\nIn case that more than one option is used, this is the order in how they are evaluated, no meter how they where introduced on the configuration file:\r\n\r\n    1. body\r\n    2. status\r\n    3. header\r\n\r\nThe reason for this order is related to performance, at the end we want to\r\nmonitor/supervise the services in an efficient way avoiding to waste extra\r\nresources, in must cases only the HTTP Headers are enough to take an action,\r\ntherefore we don't need to read the full body page, because of this if no\r\n``body`` is defined, **Epazote** will only read the Headers saving with this\r\ntime and process time.\r\n\r\n### services - expect - if_not\r\n``if_not`` is a block with an action of what to do it we don't get what we where\r\nexpecting (``expect``). See services - Actions\r\n\r\n### services - if_status  & if_header\r\nThere maybe cases in where third-party dependencies are down and because of this\r\nyour application could not be working properly, for this cases the ``if_status``\r\nand ``if_header`` could be useful.\r\n\r\nFor example if the database is your application could start responding an status\r\ncode 500 or either a custom header and based on does values take execute an\r\naction:\r\n\r\nThe format for ``if_status`` is a key-pair where key is an int representing an\r\nHTTP status code, and the value an Action option\r\n\r\nThe format for ``if_header`` is a key-pair where key is a string of something\r\nyou could relate/match and has in other if_X conditions, value is an Action.\r\n\r\nThis are the only ``if's`` and the order of execution:\r\n 1. if_status\r\n 2. if_header\r\n 3. if_not\r\n\r\nThis means that if a service uses ``if_status`` and ``if_not``, it will\r\nevaluate first the ``if_status`` and execute an Action if required, in case\r\nan ``if_status`` and ``if_header`` are set, same applies, first is evaluated\r\n``if_status``, then ``if_header`` and last ``if_not``.\r\n\r\n## services - Actions\r\nAn Action has tree options:\r\n - cmd\r\n - notify\r\n - msg\r\n\r\nThey can be used all together, only one or either none.\r\n\r\n### services - Actions - cmd (string)\r\n``cmd`` Contains the command to be executed.\r\n\r\n### services - Actions - notify (string)\r\n``notify`` Should contain ``yes``, the email email address or addresses (space separated)\r\nof the recipients that will be notified when the action is executed.\r\n\r\nIf the string is ``yes`` the global recipients will be used.\r\n\r\n### services - Actions - msg (string)\r\n``msg`` The message to send when the action is executed.\r\n\r\n## services - Test\r\n**Epazote** It is mainly used for HTTP services, for supervising other\r\napplications that don't listen or accept HTTP connections, like a database,\r\ncache engine, etc. There are tools like\r\n[daemontools](https://cr.yp.to/daemontools.html),\r\n[runit](http://smarden.org/runit/) as already mentioned, even so, **Epazote**\r\ncan eventually be used to execute an action based on the exit of a command\r\nfor example:\r\n\r\n```yaml\r\n    salt-master:\r\n        test: pgrep -f salt\r\n        if_not:\r\n            cmd: service restart salt_master\r\n            notify: operations@domain.tld\r\n```\r\n\r\nIn this case: ``test: pgrep -f salt`` will execute the ``cmd`` on the ``if_not``\r\nblock in case the exit code is > 0, from the ``pgrep`` man page:\r\n\r\n```txt\r\nEXIT STATUS\r\n     The pgrep and pkill utilities return one of the following values upon exit:\r\n\r\n          0       One or more processes were matched.\r\n          1       No processes were matched.\r\n          2       Invalid options were specified on the command line.\r\n          3       An internal error occurred.\r\n```\r\n\r\n\r\n## Extra setup\r\n*green dots give some comfort* -- Because of this when using the ``log``\r\noption an extra service could be configure as a receiver for all the post\r\nthat **Epazote** produce and based on the data obtained create a custom\r\ndashboard, something similar to: https://status.cloud.google.com/ or\r\nhttp://status.aws.amazon.com/\r\n\r\n# Issues\r\nPlease report any problem, bug, here: https://github.com/nbari/epazote/issues\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}